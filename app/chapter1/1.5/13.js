// 使用路径压缩的加权 quick-union 算法。
// 修改加权 quick-union 算法（算法 1.5），实现如练习 1.5.12 所述的路径压缩。
// 给出一列输入，使该方法能产生一棵高度为 4 的树。
// 注意：该算法的所有操作的均摊成本已知被限制在反 Ackermann 函数的范围之内，且对于实际应用中可能出现的所有 N 值均小于 5。

// 这个类已经实现好了，参见uf4.js
const UF = require('./uf4');

// 需要16个节点
const pairs = [
    [0, 1],
    [2, 3],
    [4, 5],
    [6, 7],
    [8, 9],
    [10, 11],
    [12, 13],
    [14, 15],

    [0, 2],
    [4, 6],
    [8, 10],
    [12, 14],

    [0, 4],
    [8, 12],

    [0, 8]
];

const uf = new UF(16);
for (const [p, q] of pairs) {
    uf.union(p, q);
}
// [ 0, 0, 0, 2, 0, 4, 4, 6, 0, 8, 8, 10, 8, 12, 12, 14 ]
console.log(uf.ids);