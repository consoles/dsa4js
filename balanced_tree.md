# 平衡查找树

## 2-3树

**2-3树是一种绝对平衡的树**(因为堆虽然是完全二叉树，但是最后一层可能没满，AVL树左右子树高度差最大为1)。允许树中的一个节点保存多个键。将标准二叉树中的节点称为*2节点*(含有1个键和2条链接)，*3节点*（含有2个键和3条链接）。2节点和3节点中的每条链接对应着其中保存的键所分割产生的一个区间。

> 一颗2-3树或者是一颗空树或者由以下节点构成：
> - 2节点：含有1个键（及其对应的值）和2条链接。左链接指向的2-3树中的键都小于该节点，右链接指向的2-3树中的键都大于该节点
> - 3节点：含有2个键（及其对应的值）和3条链接。左链接指向的2-3树中的键都小于该节点，中链接指向的2-3树中的键都*位于该节点的两个键之间*，右链接指向的2-3树中的键都大于该节点。

![2-3树](https://git-hexo-blog.oss-cn-beijing.aliyuncs.com/2-3-tree.png)

一颗*完美平衡*的2-3树中所有的空链接到根节点的距离是相同的。

### 插入元素

在2-3树中插入元素可以和BST一样先进行一次未命中的查找，然后将新节点挂在树的底部，但是无法保证树的*完美平衡性*。使用2-3树的主要原因是它可以通过*局部变换*保持树的完美平衡性。

#### 向2节点中插入新键

直接将2节点变为3节点即可。

![向2节点中插入](https://git-hexo-blog.oss-cn-beijing.aliyuncs.com/2-3-tree-insert-2_node.png)

#### 向一颗只有3节点的树中插入新键

1. 先将数据临时存储在3节点中，这时该节点会变成4节点(3个键4个链接)。
2. 将该4节点分解成3个2节点组成的2-3树，即中键是父节点，左右键分别是左右子节点。

![向一颗只有3节点的树中插入新键](https://git-hexo-blog.oss-cn-beijing.aliyuncs.com/2-3-tree-insert-only_3_node.png)

插入前树的高度是0，插入后树的高度是1.

#### 向一个父节点为2节点的3节点中插入新键

1. 将新键插入到3节点中，此时3节点变成4节点。
2. 将4节点的中键移动到父节点中，此时父节点变成3节点。
3. 原来的3节点中剩余的2个元素分别变成2个2节点，是父节点的2个子节点。

![向一个父节点为2节点的3节点中插入新键](https://git-hexo-blog.oss-cn-beijing.aliyuncs.com/2-3-tree-insert-3_node_parent2node.png)

因为中键被移动到父节点去了，所以树的高度不变。

#### 向一个父节点为3节点的3节点中插入新键

1. 将新键插入到3节点中，此时3节点变成4节点。
2. 将该4节点的中键插入父节点中，此时父节点也变成4节点，此时原节点变成3节点（第一步中的节点从4节点变成了3节点）。

父节点是4节点，因此父节点要进行相同的变换，即分解这个节点并将它的中键插入到它的父节点中。推广到一半情况，我们可以一直不断向上分解临时的4节点并将中键插入到更高层的父节点，直到遇到一个2节点并将它替换为一个不需要分解的3节点或者到达3节点的根。

![向一个父节点为3节点的3节点中插入新键](https://git-hexo-blog.oss-cn-beijing.aliyuncs.com/2-3-tree-insert-3_node_parent3node.jpg)

#### 分解根节点

如果插入节点到根节点的路径上全是3节点，根节点就需要变成一个临时的4节点。此时我们可以按照[向一棵只有3节点的树中插入新键](#向一颗只有3节点的树中插入新键)的方法处理这个问题。

### 局部变换

2-3树的插入算法的根本在于这些变换都是局部的，除了相关的节点和链接之外不必修改或者检查树的其他部分。每次变换中，变更的链接数量不会超过一个很小的常数。需要特别注意的是，不光在树的底部，树中的*任何地方*只要符合相应的模式，变换都可以进行。每个变换都会将4节点中的一个键送入它的父节点中，并重构相应的链接而不必要涉及树的其他部分。这些*局部变换*不会影响树的全局有序性和平衡性：任意空链接到根节点的路径长度都是相等的。

### 2-3树的生长轨迹

![标准索引案例](https://git-hexo-blog.oss-cn-beijing.aliyuncs.com/2-3-tree-build1.png)
![同一组键按照升序插入](https://git-hexo-blog.oss-cn-beijing.aliyuncs.com/2-3-tree-build2.png)

可以看出，无论输入的键是何种顺序，构造出来的2-3树高度都是一样的！(如果是BST就会退化为链表)。

> 和标准的BST从上到下生长不同，2-3树的生长是自下向上的。
> 在一个含有N个节点的2-3树的高度在floor(log3N) ~ floor(log2N)之间（树中全是3节点-树中全是2节点）。

可以确定在最坏情况下2-3树仍然有较好的性能，每个操作中处理每个节点的时间都不会超过一个很小的产能概述，而且这个操作只会访问一条路径上的节点，任何查找或者插入的成本都控制在对数级别。对比BST，2-3树要平展的多，例如含有10亿个节点的2-3树节点的高度在19-30之间。我们最多只需要访问30个节点就能在10亿个键中进行任意查找或者插入操作，这是相当惊人的！但是2-3树的实现需要考虑的情况实在太多：我们需要维护2种不同类型的节点，将被查找的键和节点中的每个键进行比较，将链接和其他信息从一种节点复制到另一种节点，将节点从一种数据类型转换为另一种数据类型。实现这些不仅需要大量的代码，而且它们所产生的额外开销可能会使算法比标准的BST更慢，平衡一棵树的初衷是为了消除最坏情况，但是我们希望这种保障所需要的代码越少越好，幸运的是红黑树我们只需要一点点的代价就能用一种统一的方式完成所有变换。

## 红黑树

红黑树的基本思想是用标准的BST(完全由2节点构成)和一些额外的信息（替换3节点）来表示2-3树。树中的链接分为2种类型：*红链接*将两个2节点连接起来构成一个3节点，*黑链接*则是2-3树中的普通链接。确切地说：我们将3节点表示未为一条*左斜*的红色链接相连的两个2节点（两个2节点其中之一是另一个的左子节点）。这种表示法的优点是：我们无需修改就能直接使用标准BST中的get方法。对于任意的2-3树，只要对节点进行变换我们都可以立即派生出一颗对应的BST。

![一条红色左链接相连的两个2节点表示一个3节点](https://git-hexo-blog.oss-cn-beijing.aliyuncs.com/red_black_tree_red_link.png)

红黑树的另一种定义是含有红黑链接并满足以下条件的BST:

1. 红链接均有左链接
2. 没有任何一个节点同时和2条红链接相连
3. 该树是***完美黑色平衡***的，即任意空链接到根节点的路径上的黑链接数量相同

满足以上定义的红黑树和相应的2-3树是一一对应的。如果我们将红黑树中的红链接画平，那么所有空链接到根节点的距离都是相同的。如果我们将红链接相连的节点合并就可以得到一颗2-3树。相反，如果将2-3树中的3节点画为由红色左链接相连的两个2节点，那么不会存在能够和两条红链接相连的节点，且树必然是黑色完美平衡的，因为黑链接就是2-3树中的普通链接，根据这些定义，这些链接必然是完美平衡的。无论我们用何种方式去定义它们，红黑树既是BST也是2-3树。

![红黑树和2-3树的一一对应关系](https://git-hexo-blog.oss-cn-beijing.aliyuncs.com/red_black_tree%262-3_tree.png)

因此我们可以在保持一一对应的基础上实现2-3树的插入算法，那么我们就可以将两个算法的优点结合起来：*BST中高效简洁的查找方法和2-3树中高效的平衡插入算法*。

红黑树的根节点是黑色，红色节点的孩子节点是黑色节，黑色节点的右孩子一定是黑节点。从任意一个节点到叶子节点，经过的黑色节点的数目是一样的（因此红黑树只是黑平衡的，不是完美平衡的二叉树,最大高度为2logN，极端情况下路径上的节点都是2-3树中对应的3节点，而AVL树左右子树的高度差为1）。所以对于增加和删除比较频繁的操作红黑树更优（因为AVL的平衡性更好，需要更多的旋转操作维护这个性质），如果数据只初始化一次后不太会变动，AVL树是更优的选择。

![红黑树与其对应的2-3树](https://git-hexo-blog.oss-cn-beijing.aliyuncs.com/red_black_tree_vs_2-3_tree.png)

### 颜色表示

为方便起见，因为每个节点只有一条指向自己的链接（从它的父节点指向它），我们将链接的颜色保存在表示Node中，使用布尔量color表示该链接的颜色，**约定空链接为黑色**。

```js
module.exports = class RedBlackTreeNode {
  constructor(key, value) {
    this.COLOR_RED = true;
    this.COLOR_BLACK = false;
    this.key = key;
    this.value = value;
    this.count = 1;
    this.color = RedBlackTreeNode.COLOR_RED; // 新创建的节点默认是红颜色，需要和红黑树对应的2-3树中的其他节点融合
    this.left = null;
    this.right = null;
  }

  static get COLOR_RED() {
    return true;
  }

  static get COLOR_BLACK() {
    return false;
  }
};
```

### 旋转

在实现的某些操作中可能会出现红色右链接或者两条连续的红链接，但是操作完成前这些情况都会被小心地旋转并修复。旋转操作会改变红链接的指向。首先假设我们有一条红色的右链接需要转化为左链接，这个操作叫做*左旋*，它对应的方法接受一条指向红黑树中某个节点的链接作为参数。假设被指向节点的右链接是红色的，这个方法会对树进行必要的调整并返回一个指向包含同一组键的子树且其左链接为红色的根节点的链接。

![左旋&右旋](https://git-hexo-blog.oss-cn-beijing.aliyuncs.com/red_black_tree_rotate.png)

左旋其实是将两个键中较小这作为根节点变换为较大者作为根节点。实现将一个红色左链接转换为红色右链接的*右旋*转换的代码完全相同，只需要将left和right互换即可。

无论是左旋还是右旋，旋转操作都会返回一条链接，我们总是会用`rotateRight()`或者`rotateLeft()`的返回值重置父节点（或者根节点）中的链接。这个链接可能是红色也可能是黑色——左旋和右旋的代码中都将通过`x.color = h.color`保留它原来的颜色。这可能会产生2条连续的红色链接，但是我们的算法会继续用旋转操作来修正这种情况。例如代码`h = rotateLeft(h)`将旋转节点h的红色右链接，使得h指向了旋转后子树的根节点（组成该子树中的所有键和旋转前相同，只是根节点发生了变化）。这种简洁性的代码是我们使用递归实现二叉查找树各种方法的主要原因，它使得旋转操作成了普通插入操作的一个简单补充。

### 插入

插入的节点永远是红色节点，因为对应的2-3树中我们首先要将新元素融合到已有的节点中，然后再维护红黑树的性质。

#### 向单个2节点中插入新键

一颗只含有一个键的红黑树只含有一个2节点。插入另一个键之后，我们马上就需要将它们旋转。如果新键小于老键，就只需要增加一个红色的节点即可，新的红黑树和单个3节点完全等价。如果新键大于老键，那么新增的红色节点将会产生一条红色的右链接。我们需要使用`root = rotateLeft(root)`来将其转换为红色的左链接并修正根节点的链接，插入操作才算完成。两种情况的结果均为一颗和单个3节点等价的红黑树，其中含有2个键，一条红链接，树的黑链接的高度是1.

![向单个2节点中插入新键](https://git-hexo-blog.oss-cn-beijing.aliyuncs.com/red_black_tree_insert_single2node.png)

#### 向树底部的2节点插入新键

用和BST相同的方式向一颗红黑树中插一个新键会在树的底部新增一个节点（为了保证有序性），但是总是用红链接将新节点和它的父节点相连。如果指向新节点的是父节点的左链接，那么父节点就直接成为了一个3节点；如果指向新节点的是父节点的右链接，这就是一个错误的3节点，但是一次左旋就能修正它。

![向树底部的2节点插入新键](https://git-hexo-blog.oss-cn-beijing.aliyuncs.com/red_black_tree_insert_bottom2node.png)

#### 向一颗双键树（一个3节点）中插入新键

这种情况又可以分为3种子情况:新键小于树中的2个键，在两者之间，或者大于树中的两个键。每种情况都会产生一个同时连接到两条红链接的节点，我们的任务就是修正这一点。

- 新键**大于**原树的2个键。最简单的情况。新键被连接到3节点的右链接。此时树是平衡的，根节点为中间大小的键，它有2条*左右红链接*分别和较小和较大的节点相连。如果我们将这两条链接的颜色都由红变黑，就可以得到由3个节点组成的、高度为2的平衡树。它正好对应一颗2-3树，**其他两种情况也最终转化为这种情况**。
- 新键**小于**原树中的2个键。会被连接到最左端的空链接，这样就会产生*两条连续的左红链接*。此时我们只需要将上层的红链接右旋即可得到第一种情况（中间键为根节点）。
- 新键**介于原树的2个键之间**。这也会产生2条连续的红链接，*一条红色左链接接一条红色右链接*，此时只需要将下层的红链接左旋即可得到第二种情况。

![向一颗双键树中插入新键的3种情况](https://git-hexo-blog.oss-cn-beijing.aliyuncs.com/red_black_tree_insert_3node.png)

#### 颜色转换

专门用一个方法`flipColors`来转换一个节点和两个红色子节点的颜色。除了将子节点的颜色由红变黑之外还将父节点的颜色由黑变红。这项操作最重要的性质在于它和旋转操作一样是局部变换，不会影响 **整棵树的黑色平衡性**。

![通过转换链接的颜色来分解4节点](https://git-hexo-blog.oss-cn-beijing.aliyuncs.com/red_black_tree_insert_flipColors.png)

[向一颗双键树中插入新键](#向一颗双键树（一个3节点）中插入新键)的时候，颜色转换会使根节点变为红色，这可能出现在很大的红黑树中。严格来说，红色根节点说明根节点是一个3-节点的一部分,但是实际情况并不是这样。因此我们在每次插入后都会将根节点设为黑色。注意：每当根节点由红变黑时树的黑链接高度就会加1。

#### 向树底部的3节点插入新键

![红黑树添加元素的3种情况可以使用一个逻辑链条串起来](https://git-hexo-blog.oss-cn-beijing.aliyuncs.com/red_black_tree_insert_element.png)

对于查询(set,get,contains)较多的情况，AVL树有优势，红黑树牺牲了平衡性(2logN高度)，但是统计性能更优(综合增删改查所有操作，因此TreeMap和TreeSet采用了红黑树)。另一种统计性能优秀的树是Splay Tree(伸展树)，它利用了局部性原理（刚被访问的内容高概率下次会被再次访问）。

一个有n个节点的红黑树，其高度最高为2log(n+1)的。在2-3树中，一个有n个节点的2-3树，其高度是logn级别的。转化为红黑树，由于所有的3-节点都转换为了一个红节点接一个黑节点，所以最坏的情况，红黑树上最长的那条路径，是红黑相间的。黑色节点的个数即为原来2-3树的高度，为logn级别的，现在黑色节点中间都穿插了红色节点，所以，这条最长的路径，其长度，即红黑树的高度，是2logn级别的。

## B树

B树是一种更适合于应用在外存场景的数据结构，考虑的是整体数据不能放在内存的情况（比如数据库）。在这个场景下，磁盘读取所消耗的性能过大，在树节点之间转移是很耗时的操作，不能忽略不计。（实际上，即使在内存中，也是如此。可以尝试一下一组数据，存在在静态数组中和存放在树中，便利访问的性能差距，虽然理论上的时间复杂度都是O(n)的。）

简单理解：b树将更多内容放在同一个节点，对同一个节点的操作转入内存中完成，减少磁盘操作，减少在外存中节点之间转移的次数，以达到提高效率的目的。

磁盘预读性，和b+树的联系：b+树中一个节点的大小和磁盘预读的一页的大小是相同的。