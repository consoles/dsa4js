## dsa4js

> 常见算法的javascript实现

### Usage

```bash
$ git clone https://github.com/consoles/dsa4js.git
$ cd dsa4js && npm install
$ mocha
```

### 选择排序

找到数组中的最小的那个元素，其次将它和数组的第一个元素进行交换（如果第一个元素本身就是最小的元素，那么它将和自己进行交换）。再次，在剩下的元素中找到最小的元素，将它和数组的第二个元素交换位置。如此反复，直到整个数组有序。核心思想：

> 不断在剩余元素中找到最小者。当前的索引将数组分成了2部分，左边是有序数组，右边是待排序。

复杂度：n次交换和(n-1) + (n-2) + ... + 1 = n(n -1)/2次比较 => O(n^2)

总体来说：

- 它是一种*输入无关*的算法，也就是说：一个完全有序的数组和顺序混乱的数组没有任何区别。
- *交换的次数最少*。交换的次数和数组的规模线性相关。

### 插入排序

和选择排序类似，当前索引将数组分成了有序和无序两部分，但是有序数组的最终位置还不确定，为了给更小的元素腾出空间，它们可能被移动。当索引到达数组的最右边的时候，整个数组就有序了。核心思想：

> 不断将元素插入到已经有序的数组的适当位置。

- 效率严重取决于*数组的初始值*。一个很大的有序（或接近有序）数组的效率将比随机的数组或者逆序数组快得多
- 插入排序非常适合于处理数组中只有几个元素的位置不正确的情况。*当倒置的元素很小的时候可能是最好的算法*。

时间复杂度是O(n^2)，但是插入排序还是比选择排序要快。

### 希尔排序

希尔排序本质上是插入排序的改进。是一种*缩小增量排序*。考虑一种极端情形：最小的元素位于数组的尽头，那么它挪动到正确的位置需要进行n-1次移动。它交换不相邻的元素以对数组的局部进行排序，最终利用插入排序将局部有序的数组排序。

> 先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为*直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的*，因此希尔排序在时间效率上比前两种方法有较大提高,*数组越大，优势越大*

[希尔排序](http://blog.csdn.net/morewindows/article/details/6668714)