## dsa4js

> 常见算法的javascript实现

### Usage

```bash
$ git clone https://github.com/consoles/dsa4js.git
$ cd dsa4js && npm install
$ mocha
```

[各种排序算法](http://wwwlgis.informatik.uni-kl.de/archiv/wwwdvs.informatik.uni-kl.de/courses/DBSREAL/SS2005/Vorlesungsunterlagen/Implementing_Sorting.pdf)

### 选择排序

找到数组中的最小的那个元素，其次将它和数组的第一个元素进行交换（如果第一个元素本身就是最小的元素，那么它将和自己进行交换）。再次，在剩下的元素中找到最小的元素，将它和数组的第二个元素交换位置。如此反复，直到整个数组有序。核心思想：

> 不断在剩余元素中找到最小者。当前的索引将数组分成了2部分，左边是有序数组，右边是待排序。

复杂度：n次交换和(n-1) + (n-2) + ... + 1 = n(n -1)/2次比较 => O(n^2)

总体来说：

- 它是一种*输入无关*的算法，也就是说：一个完全有序的数组和顺序混乱的数组没有任何区别。
- *交换的次数最少*。交换的次数和数组的规模线性相关。

### 插入排序

和选择排序类似，当前索引将数组分成了有序和无序两部分，但是有序数组的最终位置还不确定，为了给更小的元素腾出空间，它们可能被移动。当索引到达数组的最右边的时候，整个数组就有序了。核心思想：

> 不断将元素插入到已经有序的数组的适当位置。

- 效率严重取决于*数组的初始值*。一个很大的有序（或接近有序）数组的效率将比随机的数组或者逆序数组快得多
- 插入排序非常适合于处理数组中只有几个元素的位置不正确的情况。*当倒置的元素很小的时候可能是最好的算法*。

时间复杂度是O(n^2)，但是插入排序还是比选择排序要快。

### 希尔排序

希尔排序本质上是插入排序的改进。是一种*缩小增量排序*。考虑一种极端情形：最小的元素位于数组的尽头，那么它挪动到正确的位置需要进行n-1次移动。它交换不相邻的元素以对数组的局部进行排序，最终利用插入排序将局部有序的数组排序。

> 先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为*直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的*，因此希尔排序在时间效率上比前两种方法有较大提高,*数组越大，优势越大*

[希尔排序](http://blog.csdn.net/morewindows/article/details/6668714)

### 归并排序

将大数组划分成只有一个元素的数组，然后逐个比较，进行合并。典型的分治法。[分治法](http://blog.jobbole.com/100349/)

### 背包

一种不支持从中删除元素的集合数据类型——它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素（用例也可以检查背包是否为空或者背包中元素的数量）。迭代的顺序不确定且和用例无关。

### 队列

FIFO是公平性的体现。

> 南方有嘉木，谁与望天堂.

### 下压栈

栈的基本思想是LIFO。新邮件到来的时候，你总是可以看到它们在栈的最上面。这种思想的好处是我们可以及时看到最新的内容。当我们点击一个超链接的时候浏览器会进入一个新的页面（并将其压入一个栈），我们可以不断点击超链接访问新页面，但是总可以通过点击“后退”按钮重新访问以前的页面（从栈中弹出）。

#### 算术表达式求值

算术表达式可能是一个数，或者由一个左括号、一个算术表达式、一个运算符、另一个算术表达式和右括号组成的表达式。这里定义的是未省略括号的算术表达式，例如：1 + 2 * 3最该定义中应该表示为(1 + (2 * 3))。简单起见我们定义算术运算符包含二元运算加减乘除和一元运算sqrt。难点在于如何*解析*由括号、运算符和数字组成的字符串，并按照正确的顺序进行初级算术运算。这个就是Dijkstra的双栈法求值（符号栈和数字栈）。表达式由括号、运算符和操作数组成，我们按照以下的规则从左到右将其送入栈处理：

- 将操作数压入数栈
- 将操作符压入符栈
- 忽略左括号
- 遇到右括号时，弹出一个运算符，弹出所需数量的操作数，并将运算符和操作数的运算结果压入操作数栈

在处理完最后一个右括号时，操作数栈上只有一个值，它就是整个表达式的值。这个算法的原理是：每当算法遇到一个被括号包围并且由一个运算符和两个操作数组成的子表达式时，它都将运算符和操作数的计算结果压入操作数栈。这样的结果就好像在输入中用这个值代替了该子表达式，因此用这个值代替子表达式得到的结果和原来的表达式是相同的。我们可以反复应用这个规律并得到一个最终值。参见`Evaluation.js`。

#### 括号匹配问题

匹配括号是否成对出现。`[()]{}{[()()]()}`为true，而`[(])`为false。与双栈法求值算法类似：遇到左括号(`(`,`[`或者`{`)的时候入栈，遇到右括号的时候出栈判断匹配问题。

#### 括号补全问题

从标准输入得到一个缺少左括号的表达式并打印出补全括号之后的中序表达式。`1 + 2 ) * 3 - 4 ) * 5 - 6 ) ) )` => `((1 + 2) * ((3 - 4) * (5 - 6)))`

- 使用两个栈分别保存数值和操作符，分别为opStack和valueStack。顺序处理输入字符串的字符：
- 如果为操作符，压入opStack。
- 否则，如果为右括号，从valueStack取出两个操作数，从opStack取出1个操作符，添加括号组合后压入valueStack。
- 否则，为数字，压入valueStack。
以上处理办法需要输出满足以下条件，也就是有如下的假设：输入表达式是合法的。

#### 中缀转后缀

与算术表达式求值使用的算法一样，值栈和符号栈。扫描字符
- 忽略左括号
- 遇到数字压入valueStack
- 遇到符号压入opStack
- 遇到右括号从valueStack中弹出2个操作数，从opStack中弹出一个操作符，计算后缀表达式压入valueStack
- 最后valueStack中的值就是后缀表达式

#### 后缀表达式求值

- 思路类似双栈法，但是扫描字符串的时候遇到操作符的时候就需要计算结果了，可以省掉opStack
- 遇到数字压入valueStack
- 遇到操作符从valueStack中弹出2个元素，并进行相关操作后压入valueStack
- 后缀表达式的值就是栈顶的值

#### 环形链表实现的队列

```js
class Queue {
    constructor() {
        this.last = null;
    }
    enqueue(item) {
        const node = new Node(item);
        if (this.last == null) {
            this.last = node;
            node.next = node;
        } else {
            node.next = this.last.next;
            this.last.next = node;
            this.last = node;
        }
    }
    dequeue() {
        if (this.isEmpty()) return null;
        const item = this.last.next.value;
        if (this.last.next == this.last) {
            this.last = null;
        } else {
            this.last.next = this.last.next.next;
        }
        return item;
    }
    isEmpty() {
        return this.last === null;
    }
}
```

### 参考资料

- [《算法》](https://github.com/aistrate/AlgorithmsSedgewick)
- [算法4的数据文件](http://git-hexo-blog.oss-cn-beijing.aliyuncs.com/algs4-data.zip)